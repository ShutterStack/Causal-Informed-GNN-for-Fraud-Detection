{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Phase 4: Causal Inference with GNN Embeddings\n",
    "\n",
    "**Goal:** Estimate the causal effect of an intervention (a new security check) on fraud probability. We will use the powerful node embeddings from our trained GNN as features for a causal model.\n",
    "\n",
    "**Methodology:**\n",
    "1. Load the trained GNN model from MLflow.\n",
    "2. Generate node embeddings for all transactions.\n",
    "3. Simulate a treatment `T`: A binary variable indicating which transactions received the new security check.\n",
    "4. Define an outcome `Y`: The fraud label.\n",
    "5. Define confounders `W`: The GNN embeddings, which capture rich information about the transaction and its neighborhood.\n",
    "6. Use **EconML's Double Machine Learning (DML)** estimator to calculate the Average Treatment Effect (ATE)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import mlflow\n",
    "import torch\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "from econml.dml import DML\n",
    "from sklearn.ensemble import RandomForestRegressor, RandomForestClassifier\n",
    "import logging\n",
    "import os\n",
    "import sys\n",
    "\n",
    "# --- FIX 1: Add project root to Python path ---\n",
    "project_root = os.path.abspath(os.path.join(os.getcwd(), '..'))\n",
    "if project_root not in sys.path:\n",
    "    print(f\"Adding project root to path: {project_root}\")\n",
    "    sys.path.insert(0, project_root)\n",
    "# ------------------------------------------\n",
    "\n",
    "# --- FIX 2: Explicitly import the model class ---\n",
    "# This helps PyTorch's unpickler find the class definition and provides a clear error if the path is wrong.\n",
    "try:\n",
    "    from src.models import GraphSAGEModel\n",
    "    from src.graph_construction import build_graph_data\n",
    "    print(\"Successfully imported custom modules from 'src' directory.\")\n",
    "except ImportError as e:\n",
    "    print(f\"Failed to import custom modules. Error: {e}\")\n",
    "    print(\"Please ensure you are running this notebook from the 'notebooks' directory and have RESTARTED the kernel.\")\n",
    "# -----------------------------------------------\n",
    "\n",
    "logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 1. Load Model, Data, and Generate Embeddings\n",
    "\n",
    "First, you need to get the `run_id` for your best GNN model from the MLflow UI."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**IMPORTANT:** If you get a `ModuleNotFoundError` in the cell below, it means the kernel needs to be restarted to recognize the path change we made above. \n",
    "\n",
    "**To fix it:**\n",
    "1. Run the cell above this one (the one with the imports).\n",
    "2. From the menu in VS Code or Jupyter, select **\"Restart Kernel\"**.\n",
    "3. Run all the cells again from the top."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Set the MLflow tracking URI to point to the project's mlruns directory\n",
    "mlflow.set_tracking_uri('../mlruns')\n",
    "\n",
    "# !!! IMPORTANT !!!\n",
    "# Paste your GNN's Run ID from the MLflow UI below.\n",
    "GNN_RUN_ID = 'ee25bc1644ff4cca94ec2eeea0deeba2' # <--- REPLACE THIS\n",
    "\n",
    "W = None # Initialize W to ensure it exists\n",
    "model = None # Initialize model to ensure it exists\n",
    "\n",
    "try:\n",
    "    # Load the trained model\n",
    "    logged_model = f\"runs:/{GNN_RUN_ID}/graphsage-model\"\n",
    "    model = mlflow.pytorch.load_model(logged_model)\n",
    "    model.eval()\n",
    "    print(\"Model loaded successfully.\")\n",
    "\n",
    "except mlflow.exceptions.MlflowException as e:\n",
    "    print(f\"MLflow Error: {e}\")\n",
    "    print(f\"\\nPlease make sure you have replaced the placeholder with a valid Run ID from your MLflow experiment.\")\n",
    "except ModuleNotFoundError as e:\n",
    "    print(f\"Module Not Found Error: {e}\")\n",
    "    print(f\"\\nThis is a common notebook issue. Please RESTART the kernel from the menu and run all cells again.\")\n",
    "except Exception as e:\n",
    "    print(f\"An unexpected error occurred: {e}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 2. Generate Embeddings and Simulate Treatment"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# This cell will only run if the model was loaded successfully\n",
    "if model is not None:\n",
    "    # Load graph data\n",
    "    PROCESSED_DATA_PATH = '../data/processed/train_merged.feather'\n",
    "    GRAPH_DATA_PATH = '../data/processed/fraud_graph.pt'\n",
    "    data = build_graph_data(PROCESSED_DATA_PATH, GRAPH_DATA_PATH)\n",
    "    print(\"Graph data loaded successfully.\")\n",
    "\n",
    "    # Generate node embeddings (W)\n",
    "    with torch.no_grad():\n",
    "        W = model(data.x, data.edge_index).numpy()\n",
    "    print(f\"Generated embeddings (confounders W) with shape: {W.shape}\")\n",
    "\n",
    "    # Outcome Y (isFraud)\n",
    "    Y = data.y.numpy()\n",
    "\n",
    "    # Treatment T: Simulate that the security check was randomly assigned to 50% of transactions\n",
    "    T = np.random.binomial(1, 0.5, size=data.num_nodes)\n",
    "\n",
    "    print(f\"Shape of Y (outcome): {Y.shape}\")\n",
    "    print(f\"Shape of T (treatment): {T.shape}\")\n",
    "else:\n",
    "    print(\"Model was not loaded due to an error in the previous cell. Please fix the error and re-run.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 3. Estimate Average Treatment Effect (ATE) with DML\n",
    "\n",
    "DML is a powerful technique that uses two machine learning models to remove confounding bias:\n",
    "- A model to predict the outcome `Y` from the confounders `W`.\n",
    "- A model to predict the treatment `T` from the confounders `W`."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "if W is not None:\n",
    "    # Initialize the DML estimator\n",
    "    est = DML(\n",
    "        model_y=RandomForestRegressor(n_estimators=100, min_samples_leaf=10, random_state=42),\n",
    "        model_t=RandomForestClassifier(n_estimators=100, min_samples_leaf=10, random_state=42),\n",
    "        random_state=42\n",
    "    )\n",
    "\n",
    "    # Fit the estimator. We only use W (confounders) here as we are interested in the ATE,\n",
    "    # not heterogeneous effects that depend on other features X.\n",
    "    print(\"Fitting the DML estimator...\")\n",
    "    est.fit(Y, T, W=W)\n",
    "    print(\"Fit complete.\")\n",
    "\n",
    "    # Get the average treatment effect and its confidence interval\n",
    "    # .ate_ is the property that stores the ATE after fitting\n",
    "    ate_estimate = est.ate_\n",
    "    ate_interval = est.ate_interval()\n",
    "\n",
    "    print(f\"\\nEstimated Average Treatment Effect (ATE): {ate_estimate:.4f}\")\n",
    "    print(f\"95% Confidence Interval: [{ate_interval[0]:.4f}, {ate_interval[1]:.4f}]\")\n",
    "else:\n",
    "    print(\"Cannot estimate ATE because the previous steps failed.\")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### 4. Interpretation\n",
    "\n",
    "The ATE tells us the average change in the probability of fraud if we were to apply the security check to all transactions, compared to none of them.\n",
    "\n",
    "- **A negative ATE** would suggest that the security check *reduces* the probability of fraud.\n",
    "- **A positive ATE** would suggest it *increases* it (which would be unexpected).\n",
    "- **An ATE close to zero** with a confidence interval that includes zero would suggest the check has no statistically significant effect."
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
